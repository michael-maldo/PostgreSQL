"use strict";(globalThis.webpackChunkpostgresql=globalThis.webpackChunkpostgresql||[]).push([[8042],{7147:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>E,frontMatter:()=>c,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"advanced/sql - advanced","title":"SQL - Advanced Features","description":"Basic SQL discussed how to store and access data in PostgreSQL.","source":"@site/docs/advanced/sql - advanced.mdx","sourceDirName":"advanced","slug":"/advanced/sql - advanced","permalink":"/docs/advanced/sql - advanced","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"advanced","permalink":"/docs/category/advanced"},"next":{"title":"psql meta commands","permalink":"/docs/advanced/psql - meta commands"}}');var s=a(4848),i=a(8453);const c={sidebar_position:1},r="SQL - Advanced Features",l={},o=[{value:"Views",id:"views",level:2},{value:"security / permission control",id:"security--permission-control",level:3},{value:"Foreign Keys",id:"foreign-keys",level:2},{value:"Transactions",id:"transactions",level:2},{value:"init transdb",id:"init-transdb",level:3},{value:"trans queries",id:"trans-queries",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"sql---advanced-features",children:"SQL - Advanced Features"})}),"\n",(0,s.jsxs)(e.p,{children:["Basic SQL discussed how to store and access data in PostgreSQL. ",(0,s.jsx)("br",{}),"\nMore advanced features of SQL discussed here"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"how to simplify management"}),"\n",(0,s.jsx)(e.li,{children:"prevent loss or corruption of your data."}),"\n",(0,s.jsx)(e.li,{children:"PostgreSQL extensions."}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"views",children:"Views"}),"\n",(0,s.jsx)(e.p,{children:"best used for"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"a stable API layer"}),"\n",(0,s.jsx)(e.li,{children:"simplifying complex queries"}),"\n",(0,s.jsx)(e.li,{children:"security / permission control"}),"\n",(0,s.jsx)(e.li,{children:"virtual columns / computed fields"}),"\n",(0,s.jsx)(e.li,{children:"providing backward compatibility"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",metastring:'title="sql"',children:"-- creates a view\nCREATE OR REPLACE VIEW sf_weather_list AS\nSELECT name, location, temp_lo, temp_hi, prcp, cur_date\n    FROM weather JOIN cities on city = name\n    WHERE city = 'San Francisco';\n\n-- query/use a view like any other table\nSELECT name, location, temp_lo, temp_hi, prcp, cur_date\n    FROM sf_weather_list;\n\n"})}),"\n",(0,s.jsx)(e.h3,{id:"security--permission-control",children:"security / permission control"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",metastring:'title="sql"',children:"-- expose only part of a table.\nCREATE VIEW public_users AS\nSELECT id, name FROM users;\n\n\n-- Give permissions\nGRANT SELECT ON public_users TO user1;\n"})}),"\n",(0,s.jsx)(e.h2,{id:"foreign-keys",children:"Foreign Keys"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",metastring:'title="sql"',children:'-- failed - referenced table(cities), column (name) - no unique restrain\nbasicsdb=# ALTER TABLE weather ADD FOREIGN KEY (city) REFERENCES cities(name);\nERROR:  there is no unique constraint matching given keys for referenced table "cities"\n\n-- alter table, add primary key to cities, name\nbasicsdb=# ALTER TABLE cities ADD CONSTRAINT cities_name_pk PRIMARY KEY (name);\nALTER TABLE\n\n-- alter table weather - add foreign key city column, references cities, name\nbasicsdb=# ALTER TABLE weather ADD FOREIGN KEY (city) REFERENCES cities(name);\n\n-- failed weather contains - \'Hayward\' city not in cities,name\nERROR:  insert or update on table "weather" violates foreign key constraint "weather_city_fkey"\nDETAIL:  Key (city)=(Hayward) is not present in table "cities".\n\n-- added entry Hayward to cities table\nbasicsdb=# insert  into cities ("name", "location") values (\'Hayward\', \'123.57,-25.43\');\nINSERT 0 1\n\n-- success alter table, add foreign key to city, refrencing cities, name\nbasicsdb=# ALTER TABLE weather ADD FOREIGN KEY (city) REFERENCES cities(name);\nALTER TABLE\n\nbasicsdb=# \\d cities\n                       Table "basics.cities"\n  Column  |         Type          | Collation | Nullable | Default\n----------+-----------------------+-----------+----------+---------\n name     | character varying(80) |           | not null |\n location | point                 |           |          |\nIndexes:\n    "cities_name_pk" PRIMARY KEY, btree (name)\nReferenced by:\n    TABLE "weather" CONSTRAINT "weather_city_fkey" FOREIGN KEY (city) REFERENCES cities(name)\n\n\n\nbasicsdb=# \\d weather;\n                      Table "basics.weather"\n  Column  |         Type          | Collation | Nullable | Default\n----------+-----------------------+-----------+----------+---------\n city     | character varying(80) |           |          |\n temp_lo  | integer               |           |          |\n temp_hi  | integer               |           |          |\n prcp     | real                  |           |          |\n cur_date | date                  |           |          |\nForeign-key constraints:\n    "weather_city_fkey" FOREIGN KEY (city) REFERENCES cities(name)\n\nbasicsdb=#\n\n'})}),"\n",(0,s.jsx)(e.h2,{id:"transactions",children:"Transactions"}),"\n",(0,s.jsx)(e.p,{children:"Transactions are a fundamental concept of all database systems. The essential point of a transaction is that\nit bundles multiple steps into a single, all-or-nothing operation. The intermediate states between the steps\nare not visible to other concurrent transactions, and if some failure occurs that prevents the transaction\nfrom completing, then none of the steps affect the database at all."}),"\n",(0,s.jsx)(e.h3,{id:"init-transdb",children:"init transdb"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",metastring:'title="sql"',children:"\nDROP DATABASE IF EXISTS transdb;\nCREATE DATABASE transdb;\n\\c transdb;\n\nCREATE SCHEMA test;\nSET SEARCH_PATH TO test, public;\n\n\n-- Drop old tables if they exist (optional)\n-- DROP TABLE IF EXISTS accounts CASCADE;\n-- DROP TABLE IF EXISTS branches CASCADE;\n\n-------------------------------------\n-- 1. Create branches table\n-------------------------------------\nCREATE TABLE branches (\n    id SERIAL PRIMARY KEY,\n    name TEXT NOT NULL UNIQUE,\n    balance NUMERIC(12,2) NOT NULL DEFAULT 0\n);\n\n-------------------------------------\n-- 2. Create accounts table\n-------------------------------------\nCREATE TABLE accounts (\n    id SERIAL PRIMARY KEY,\n    name TEXT UNIQUE NOT NULL,\n    branch_id INT NOT NULL REFERENCES branches(id),\n    balance NUMERIC(12,2) NOT NULL DEFAULT 0\n);\n\n\n-- bulk inserts\n-- good for initializing data base from scratch\n-- 10+ branches, thousands of accounts, CSV input\n-- Begin transaction\nBEGIN;\n\n-- Create temporary staging tables\nCREATE TEMP TABLE staging_branches (\n    name text,\n    balance numeric\n);\n\nCREATE TEMP TABLE staging_accounts (\n    branch_name text,\n    name text,\n    balance numeric\n);\n\n-- Load CSVs into staging tables\n-- Adjust paths as needed\n\\copy staging_branches(name, balance) FROM 'branches.csv' DELIMITER ',' CSV HEADER;\n\\copy staging_accounts(branch_name, name, balance) FROM 'accounts.csv' DELIMITER ',' CSV HEADER;\n\n-- Insert branches into main table, capture IDs\n-- Use CTE to map branch_name to branch_id\nWITH inserted_branches AS (\n    INSERT INTO branches(name, balance)\n    SELECT name, balance\n    FROM staging_branches\n    RETURNING id, name\n)\n-- Insert accounts using the branch IDs\nINSERT INTO accounts(name, branch_id, balance)\nSELECT a.name, b.id, a.balance\nFROM staging_accounts a\nJOIN inserted_branches b ON a.branch_name = b.name;\n\n-- Commit transaction\nCOMMIT;\n\n\n\n\n-------------------------------------\n-- 3. Insert branch data\n-------------------------------------\n\n-- 4. Insert account data\n-------------------------------------\n-- insert using CTE\n/*\nWITH BranchA AS (\n    INSERT INTO branches(name, balance)\n    VALUES ('BranchA', 5000)\n    RETURNING id\n)\nINSERT INTO accounts(name, branch_id, balance)\nSELECT * FROM (\n    SELECT 'Alice', id, 100.00 FROM BranchA\n    UNION ALL\n    SELECT 'Wally', id, 200.00 FROM BranchA\n) AS t;\n\n\nWITH BranchB AS (\n    INSERT INTO branches(name, balance)\n    VALUES ('BranchB', 5000)\n    RETURNING id\n)\nINSERT INTO accounts(name, branch_id, balance)\nSELECT * FROM (\n    SELECT 'Mark', id, 100.00 FROM BranchB\n    UNION ALL\n    SELECT 'John', id, 200.00 FROM BranchB\n) AS t;\n\n*/\n\n-- insert using INSERT ... VALUES\n\n/*\n\nDO $$\nDECLARE\n    branch_a_id INT;\n    branch_b_id INT;\nBEGIN\n    INSERT INTO branches(name, balance)\n    VALUES ('BranchA', 5000)\n    RETURNING id INTO branch_a_id;\n\n    INSERT INTO accounts(name, branch_id, balance)\n    VALUES ('Alice', branch_a_id, 100.00),\n           ('Wally', branch_a_id, 200.00);\n\n    INSERT INTO branches(name, balance)\n    VALUES ('BranchB', 5000)\n    RETURNING id INTO branch_b_id;\n\n    INSERT INTO accounts(name, branch_id, balance)\n    VALUES ('Alice', branch_b_id, 100.00),\n           ('Wally', branch_b_id, 200.00);\nEND $$;\n\n\n*/\n\n/*\n\nBEGIN;\n\n-- Insert branch and capture returned id\n-- make sure there is no semicolon after the SQL --\n-- gset is the one that executes the statement\n-- and captures the return into a variable\nINSERT INTO branches(name, balance)\nVALUES ('BranchA', 5000)\nRETURNING id\n\\gset\n\n-- Use the returned id in subsequent inserts\nINSERT INTO accounts(name, branch_id, balance) VALUES\n('Alice', :id, 100.00),\n('Wally', :id, 200.00);\n\nCOMMIT;\n\n\n*/\n\n/*\n-- for a different variable name\n\nINSERT INTO branches(name, balance)\nVALUES ('BranchA', 5000)\nRETURNING id AS branch_id\n\\gset\n\n-- Now you can use :branch_id\nINSERT INTO accounts(name, branch_id, balance) VALUES\n('Alice', :branch_id, 100.00),\n('Wally', :branch_id, 200.00);\n\n\n\n*/\n\n\n\n/*\n\nLong id = jdbcTemplate.queryForObject(\n    \"INSERT INTO branches(name) VALUES (?) RETURNING id\",\n    Long.class,\n    \"New Branch\"\n );\n\n jdbcTemplate.update(\n    \"INSERT INTO accounts(name, branch_id, balance) VALUES (?, ?, ?)\",\n    \"Mark\", id, 500.00\n );\n\n*/\n\n-------------------------------------\n-- 5. Show initial data\n-------------------------------------\nSELECT * FROM accounts;\nSELECT * FROM branches;\n\n\n"})}),"\n",(0,s.jsx)(e.h3,{id:"trans-queries",children:"trans queries"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",metastring:'title="sql"',children:"\nUPDATE accounts SET balance = balance - 100.00\nWHERE name = 'Alice';\nUPDATE branches SET balance = balance - 100.00\nWHERE name = (SELECT branch_name FROM accounts WHERE name =\n'Alice');\nUPDATE accounts SET balance = balance + 100.00\nWHERE name = 'Bob';\nUPDATE branches SET balance = balance + 100.00\nWHERE name = (SELECT branch_name FROM accounts WHERE name =\n'Bob');\n\n"})})]})}function E(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>c,x:()=>r});var t=a(6540);const s={},i=t.createContext(s);function c(n){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:c(n.components),t.createElement(i.Provider,{value:e},n.children)}}}]);